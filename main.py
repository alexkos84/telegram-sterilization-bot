import os
import telebot
from telebot import types
from flask import Flask, request
from datetime import datetime
import time
import logging

# üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤–≤–µ—Ä—Ö)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# üìÑ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç–∞ –∏–∑ HTML-—Ñ–∞–π–ª–æ–≤
def load_text(filename):
    try:
        path = os.path.join("assets", filename)
        with open(path, encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        logger.error(f"‚ùå –§–∞–π–ª {filename} –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        return f"–ö–æ–Ω—Ç–µ–Ω—Ç –∏–∑ {filename} –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {filename}: {e}")
        return "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"

def load_all_texts():
    texts = {}
    assets_dir = "assets"
    
    if not os.path.exists(assets_dir):
        logger.warning(f"üìÅ –ü–∞–ø–∫–∞ {assets_dir} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!")
        return texts
    
    try:
        for filename in os.listdir(assets_dir):
            if filename.endswith('.html'):
                key = filename.replace('.html', '')
                texts[key] = load_text(filename)
                logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω —Ñ–∞–π–ª: {filename} -> {key}")
        return texts
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤: {e}")
        return texts

# üñºÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
IMAGES = {
    'paid_text': 'https://example.com/paid_sterilization.jpg',  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É
    'free_text': 'https://example.com/free_sterilization.jpg'   # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É
}

# –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ - –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ assets/images/
LOCAL_IMAGES = {
    'paid_text': os.path.join('assets', 'images', 'paid.jpg'),
    'free_text': os.path.join('assets', 'images', 'free.jpg')
}

# üóÇÔ∏è –ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö —Ç–µ–∫—Å—Ç–æ–≤
texts = load_all_texts()
paid_text = texts.get('paid_text', '–ü–ª–∞—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞')
free_text = texts.get('free_text', '–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞')

# ‚öôÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = os.environ.get('TOKEN')
if not TOKEN:
    logger.error("‚ùå –û—à–∏–±–∫–∞: –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!")
    exit(1)

PORT = int(os.environ.get('PORT', 8080))
WEBHOOK_URL = (
    os.environ.get('RAILWAY_STATIC_URL') or 
    os.environ.get('RAILWAY_PUBLIC_DOMAIN') or
    os.environ.get('WEBHOOK_URL')
)

bot = telebot.TeleBot(TOKEN)
app = Flask(__name__)

# üñºÔ∏è –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
def send_message_with_image(chat_id, text, image_key, use_local=False):
    try:
        if use_local:
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
            image_path = LOCAL_IMAGES.get(image_key)
            if image_path and os.path.exists(image_path):
                with open(image_path, 'rb') as photo:
                    bot.send_photo(
                        chat_id,
                        photo,
                        caption=text,
                        parse_mode="HTML",
                        disable_web_page_preview=True
                    )
                return True
        else:
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ URL
            image_url = IMAGES.get(image_key)
            if image_url:
                bot.send_photo(
                    chat_id,
                    image_url,
                    caption=text,
                    parse_mode="HTML",
                    disable_web_page_preview=True
                )
                return True
        
        # –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
        bot.send_message(
            chat_id,
            text,
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        return False
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
        # Fallback - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
        bot.send_message(
            chat_id,
            text,
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        return False

# üåê Webhook –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
@app.route(f'/{TOKEN}', methods=['POST'])
def webhook():
    try:
        if request.headers.get('content-type') == 'application/json':
            json_string = request.get_data().decode('utf-8')
            update = telebot.types.Update.de_json(json_string)
            bot.process_new_updates([update])
            return '', 200
        return 'Bad request', 400
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ webhook: {e}")
        return 'Internal error', 500

@app.route('/')
def home():
    return {
        "status": "ü§ñ Bot is running!",
        "time": datetime.now().strftime('%H:%M:%S'),
        "date": datetime.now().strftime('%d.%m.%Y')
    }

@app.route('/health')
def health():
    return {
        "status": "ok", 
        "time": datetime.now().isoformat(),
        "bot_info": "Telegram Bot Active"
    }

# üé¨ –°—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞
@bot.message_handler(commands=['start'])
def start(message):
    try:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add("üí∞ –ü–ª–∞—Ç–Ω–∞—è", "üÜì –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è")
        bot.send_message(
            message.chat.id, 
            "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Å—Ç–µ—Ä–∏–ª–∏–∑–∞—Ü–∏–∏:",
            reply_markup=markup,
            parse_mode="HTML"
        )
        logger.info(f"üë§ –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {message.from_user.id}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ /start: {e}")
        bot.send_message(message.chat.id, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")

# üìä –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞
@bot.message_handler(commands=['status'])
def status(message):
    try:
        now = datetime.now().strftime('%d.%m.%Y %H:%M:%S')
        bot.send_message(
            message.chat.id,
            f"ü§ñ <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞</b>\n\n‚úÖ –ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω\n‚è∞ –í—Ä–µ–º—è: <code>{now}</code>\nüÜî –í–∞—à ID: <code>{message.from_user.id}</code>",
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ /status: {e}")
        bot.send_message(message.chat.id, "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞.")

# üéØ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫
@bot.message_handler(func=lambda m: True)
def handle_buttons(message):
    try:
        button_mapping = {
            "üí∞ –ü–ª–∞—Ç–Ω–∞—è": "paid_text",
            "üÜì –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è": "free_text"
        }
        
        if message.text in button_mapping:
            content_key = button_mapping[message.text]
            content = texts.get(content_key, "–ö–æ–Ω—Ç–µ–Ω—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
            # –ò–∑–º–µ–Ω–∏—Ç–µ use_local=True –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
            send_message_with_image(message.chat.id, content, content_key, use_local=False)
            
        else:
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            markup.add("üí∞ –ü–ª–∞—Ç–Ω–∞—è", "üÜì –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è")
            bot.send_message(
                message.chat.id,
                "‚ùì –í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –∏–∑ –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ:\n\nüí∞ –ü–ª–∞—Ç–Ω–∞—è\nüÜì –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è\n\n–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã: /start, /status",
                reply_markup=markup,
                parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–Ω–æ–ø–æ–∫: {e}")
        bot.send_message(message.chat.id, "–û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

# üîÑ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook
def setup_webhook():
    try:
        bot.remove_webhook()
        time.sleep(2)
        if not WEBHOOK_URL:
            logger.error("‚ùå WEBHOOK_URL –Ω–µ –∑–∞–¥–∞–Ω!")
            return False
        full_url = f"https://{WEBHOOK_URL}/{TOKEN}"
        result = bot.set_webhook(url=full_url, max_connections=10)
        if result:
            logger.info(f"‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {full_url}")
            return True
        else:
            logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook")
            return False
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook: {e}")
        return False

# üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
if __name__ == "__main__":
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ Telegram –±–æ—Ç–∞...")
    if setup_webhook():
        app.run(host='0.0.0.0', port=PORT)
    else:
        logger.error("üö® Webhook –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é.")
