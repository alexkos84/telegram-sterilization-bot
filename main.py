import os
import telebot
from telebot import types
from flask import Flask, request, jsonify
from datetime import datetime, timedelta
import time
import logging
import json
import requests
from bs4 import BeautifulSoup
import re
from typing import Dict, List, Optional
import random
from urllib.parse import quote_plus
import cloudscraper

# üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class YaltaPodslushanoParser:
    """–ü–∞—Ä—Å–µ—Ä –∫–∞–Ω–∞–ª–∞ –Ø–ª—Ç–∞ –ü–æ–¥—Å–ª—É—à–∞–Ω–æ"""
    
    def __init__(self):
        self.channel = {
            'username': 'yalta_podslushano',
            'url': 'https://t.me/yalta_podslushano',
            'name': '–Ø–ª—Ç–∞ –ü–æ–¥—Å–ª—É—à–∞–Ω–æ'
        }
        self.posts_cache = []
        self.last_update = None
        self.last_attempt = None
        self.failure_count = 0
        
        # –°–æ–∑–¥–∞–µ–º CloudScraper —Å–µ—Å—Å–∏—é –¥–ª—è –æ–±—Ö–æ–¥–∞ Cloudflare
        try:
            self.scraper = cloudscraper.create_scraper(
                browser={
                    'browser': 'chrome',
                    'platform': 'windows',
                    'mobile': False
                }
            )
        except:
            self.scraper = requests.Session()
            logger.warning("‚ö†Ô∏è CloudScraper –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π requests")
        
        # –†–æ—Ç–∞—Ü–∏—è User-Agents
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        ]
    
    def get_channel_posts(self, limit: int = 5) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ —Å –∫–∞–Ω–∞–ª–∞"""
        self.last_attempt = datetime.now()
        
        try:
            url = f'https://t.me/s/{self.channel["username"]}'
            logger.info(f"üåê –ü–∞—Ä—Å–∏–Ω–≥ –∫–∞–Ω–∞–ª–∞: {url}")
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º headers
            headers = {
                'User-Agent': random.choice(self.user_agents),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
                'Accept-Language': 'ru-RU,ru;q=0.9,en;q=0.8',
                'DNT': '1'
            }
            
            # –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å
            response = self.scraper.get(url, headers=headers, timeout=20)
            
            if response.status_code == 200:
                posts = self.parse_html_content(response.text, limit)
                if posts:
                    self.posts_cache = posts
                    self.last_update = datetime.now()
                    self.failure_count = 0
                    logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤")
                    return posts
            else:
                logger.warning(f"‚ö†Ô∏è HTTP –æ—à–∏–±–∫–∞: {response.status_code}")
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
            self.failure_count += 1
        
        # –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—ç—à –∏–ª–∏ –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
        return self.posts_cache if self.posts_cache else []
    
    def parse_html_content(self, html: str, limit: int) -> List[Dict]:
        """–ü–∞—Ä—Å–∏–Ω–≥ HTML –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
        try:
            soup = BeautifulSoup(html, 'html.parser')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
            if "Cloudflare" in html or "checking your browser" in html.lower():
                logger.warning("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∑–∞—â–∏—Ç–∞ Cloudflare")
                return []
            
            # –ò—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
            messages = soup.select('div.tgme_widget_message_wrap')
            if not messages:
                logger.warning("‚ùå –°–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                return []
            
            posts = []
            for msg_div in messages[:limit*2]:  # –ë–µ—Ä–µ–º —Å –∑–∞–ø–∞—Å–æ–º –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                post = self.parse_message_div(msg_div)
                if post:
                    posts.append(post)
                    if len(posts) >= limit:
                        break
            
            return posts
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ HTML: {e}")
            return []
    
    def parse_message_div(self, div) -> Optional[Dict]:
        """–ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            # ID –ø–æ—Å—Ç–∞
            post_id = div.get('data-post', '') or f"msg_{hash(str(div)[:100]) % 10000}"
            if '/' in str(post_id):
                post_id = str(post_id).split('/')[-1]
            
            # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            text_elem = div.select_one('.tgme_widget_message_text')
            text = text_elem.get_text(separator='\n', strip=True) if text_elem else ""
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–µ –∏–ª–∏ –ø—É—Å—Ç—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
            if not text or len(text) < 30:
                return None
            
            # –î–∞—Ç–∞
            date_elem = div.select_one('.tgme_widget_message_date time')
            date_str = date_elem.get('datetime', '–ù–µ–¥–∞–≤–Ω–æ') if date_elem else "–ù–µ–¥–∞–≤–Ω–æ"
            
            # –§–æ—Ç–æ/–≤–∏–¥–µ–æ
            media = self.extract_media(div)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ—Å—Ç
            return {
                'id': post_id,
                'text': text,
                'date': date_str,
                'url': f"{self.channel['url']}/{post_id}",
                'media': media,
                'has_media': bool(media),
                'source': 'parsed'
            }
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            return None
    
    def extract_media(self, div):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –º–µ–¥–∏–∞ (—Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ)"""
        # –§–æ—Ç–æ
        photo_elem = div.select_one('.tgme_widget_message_photo_wrap[style*="background-image"]')
        if photo_elem:
            style = photo_elem.get('style', '')
            match = re.search(r"background-image:url\('([^']+)'\)", style)
            if match:
                return {'type': 'photo', 'url': match.group(1)}
        
        # –í–∏–¥–µ–æ
        video_elem = div.select_one('video.tgme_widget_message_video')
        if video_elem:
            video_src = video_elem.get('src')
            if video_src:
                return {'type': 'video', 'url': video_src}
        
        return None
    
    def get_cached_posts(self, limit: int = 5) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤"""
        # –û–±–Ω–æ–≤–ª—è–µ–º –µ—Å–ª–∏ –¥–∞–≤–Ω–æ –Ω–µ –æ–±–Ω–æ–≤–ª—è–ª–∏ –∏–ª–∏ –∫—ç—à –ø—É—Å—Ç–æ–π
        should_update = (
            not self.last_update or 
            (datetime.now() - self.last_update).seconds > 3600 or  # 1 —á–∞—Å
            not self.posts_cache
        )
        
        if should_update:
            return self.get_channel_posts(limit)
        
        return self.posts_cache[:limit]

class YaltaPodslushanoBot:
    """–ë–æ—Ç –¥–ª—è –∫–∞–Ω–∞–ª–∞ –Ø–ª—Ç–∞ –ü–æ–¥—Å–ª—É—à–∞–Ω–æ"""
    
    def __init__(self):
        self.token = os.environ.get('TOKEN')
        if not self.token:
            logger.error("‚ùå TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            exit(1)
        
        self.bot = telebot.TeleBot(self.token)
        self.parser = YaltaPodslushanoParser()
        self.app = Flask(__name__)
        self.port = int(os.environ.get('PORT', 8080))
        self.webhook_url = os.environ.get('WEBHOOK_URL')
        
        self.setup_handlers()
        self.setup_routes()
    
    def send_post(self, chat_id: int, post: Dict):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –æ–¥–Ω–æ–≥–æ –ø–æ—Å—Ç–∞"""
        try:
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
            post_text = (
                f"üì¢ <b>{self.parser.channel['name']}</b>\n\n"
                f"{post['text']}\n\n"
                f"üîó <a href='{post['url']}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –∫–∞–Ω–∞–ª–µ</a>"
            )
            
            # –û–±—Ä–µ–∑–∞–µ–º –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π
            if len(post_text) > 1024:
                post_text = post_text[:1000] + "..."
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–µ–¥–∏–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
            if post.get('has_media'):
                media = post['media']
                if media['type'] == 'photo':
                    self.bot.send_photo(
                        chat_id,
                        media['url'],
                        caption=post_text,
                        parse_mode="HTML",
                        reply_markup=types.InlineKeyboardMarkup().add(
                            types.InlineKeyboardButton("üì¢ –û—Ç–∫—Ä—ã—Ç—å –≤ –∫–∞–Ω–∞–ª–µ", url=post['url'])
                        )
                    )
                    return
                elif media['type'] == 'video':
                    self.bot.send_video(
                        chat_id,
                        media['url'],
                        caption=post_text,
                        parse_mode="HTML",
                        reply_markup=types.InlineKeyboardMarkup().add(
                            types.InlineKeyboardButton("üì¢ –û—Ç–∫—Ä—ã—Ç—å –≤ –∫–∞–Ω–∞–ª–µ", url=post['url'])
                        )
                    )
                    return
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∫ —Ç–µ–∫—Å—Ç –µ—Å–ª–∏ –Ω–µ—Ç –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å
            self.bot.send_message(
                chat_id,
                post_text,
                parse_mode="HTML",
                disable_web_page_preview=False,
                reply_markup=types.InlineKeyboardMarkup().add(
                    types.InlineKeyboardButton("üì¢ –û—Ç–∫—Ä—ã—Ç—å –≤ –∫–∞–Ω–∞–ª–µ", url=post['url'])
                )
            )
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ—Å—Ç–∞: {e}")

    def setup_handlers(self):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥"""
        
        @self.bot.message_handler(commands=['start'])
        def start_handler(message):
            welcome_text = (
                f"üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b>\n\n"
                f"–≠—Ç–æ –±–æ—Ç –¥–ª—è –∫–∞–Ω–∞–ª–∞ <b>{self.parser.channel['name']}</b>\n\n"
                f"üìå –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                f"/posts - –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ—Å—Ç—ã\n"
                f"/update - –æ–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ\n"
                f"/channel - —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª"
            )
            
            self.bot.send_message(
                message.chat.id,
                welcome_text,
                parse_mode="HTML",
                reply_markup=self.get_main_keyboard()
            )
        
        @self.bot.message_handler(commands=['posts'])
        def posts_handler(message):
            self.bot.send_message(message.chat.id, "üîÑ –ü–æ–ª—É—á–∞—é –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ—Å—Ç—ã...")
            posts = self.parser.get_cached_posts(5)
            
            if not posts:
                self.bot.send_message(
                    message.chat.id,
                    "üòï –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ—Å—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                    reply_markup=self.get_main_keyboard()
                )
                return
            
            for post in posts:
                self.send_post(message.chat.id, post)
                time.sleep(0.5)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –ø–æ—Å—Ç–∞–º–∏
            
            self.bot.send_message(
                message.chat.id,
                f"‚úÖ –ü–æ–∫–∞–∑–∞–Ω–æ {len(posts)} –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –ø–æ—Å—Ç–æ–≤\n\n"
                f"üîÑ –î–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: /update\n"
                f"üì¢ –ö–∞–Ω–∞–ª: {self.parser.channel['url']}",
                reply_markup=self.get_main_keyboard()
            )
        
        @self.bot.message_handler(commands=['update'])
        def update_handler(message):
            """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ"""
            self.bot.send_message(message.chat.id, "üîÑ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ...")
            
            try:
                posts = self.parser.get_channel_posts(5)
                if posts:
                    self.bot.send_message(
                        message.chat.id,
                        f"‚úÖ –£—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ! –ü–æ–ª—É—á–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤.\n"
                        f"üìÖ –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {datetime.now().strftime('%H:%M:%S')}",
                        reply_markup=self.get_main_keyboard()
                    )
                else:
                    self.bot.send_message(
                        message.chat.id,
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–≤—ã–µ –ø–æ—Å—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                        reply_markup=self.get_main_keyboard()
                    )
            except Exception as e:
                self.bot.send_message(
                    message.chat.id,
                    f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {str(e)[:200]}",
                    reply_markup=self.get_main_keyboard()
                )
        
        @self.bot.message_handler(commands=['channel'])
        def channel_handler(message):
            """–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª"""
            self.bot.send_message(
                message.chat.id,
                f"üì¢ <b>{self.parser.channel['name']}</b>\n\n"
                f"üîó {self.parser.channel['url']}",
                parse_mode="HTML",
                reply_markup=types.InlineKeyboardMarkup().add(
                    types.InlineKeyboardButton("üì¢ –ü–µ—Ä–µ–π—Ç–∏ –≤ –∫–∞–Ω–∞–ª", url=self.parser.channel['url'])
                )
            )
        
        @self.bot.message_handler(func=lambda m: True)
        def default_handler(message):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
            self.bot.send_message(
                message.chat.id,
                "‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã:\n\n"
                "/posts - –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ—Å—Ç—ã\n"
                "/update - –æ–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ\n"
                "/channel - —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª",
                reply_markup=self.get_main_keyboard()
            )
    
    def get_main_keyboard(self):
        """–ì–ª–∞–≤–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞"""
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add("/posts", "/update")
        markup.add("/channel")
        return markup
    
    def setup_routes(self):
        """Flask –º–∞—Ä—à—Ä—É—Ç—ã"""
        
        @self.app.route(f'/{self.token}', methods=['POST'])
        def webhook():
            if request.headers.get('content-type') == 'application/json':
                json_string = request.get_data().decode('utf-8')
                update = telebot.types.Update.de_json(json_string)
                self.bot.process_new_updates([update])
                return '', 200
            return 'Bad request', 400
        
        @self.app.route('/')
        def home():
            return jsonify({
                "status": "YaltaPodslushano Bot",
                "channel": self.parser.channel['url'],
                "posts_cached": len(self.parser.posts_cache),
                "last_update": self.parser.last_update.isoformat() if self.parser.last_update else None
            })

    def setup_webhook(self) -> bool:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook"""
        try:
            self.bot.remove_webhook()
            time.sleep(2)
            
            if not self.webhook_url:
                logger.error("‚ùå WEBHOOK_URL –Ω–µ –∑–∞–¥–∞–Ω!")
                return False
            
            full_url = f"https://{self.webhook_url}/{self.token}"
            result = self.bot.set_webhook(url=full_url)
            
            if result:
                logger.info(f"‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {full_url}")
                return True
            else:
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook: {e}")
            return False

    def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –¥–ª—è –Ø–ª—Ç–∞ –ü–æ–¥—Å–ª—É—à–∞–Ω–æ...")
        
        # –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –ø–æ—Å—Ç–æ–≤
        try:
            posts = self.parser.get_cached_posts()
            logger.info(f"‚úÖ –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏: {e}")
        
        # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
        if self.setup_webhook():
            logger.info("üåê –ó–∞–ø—É—Å–∫ –≤ webhook —Ä–µ–∂–∏–º–µ")
            self.app.run(host='0.0.0.0', port=self.port)
        else:
            logger.info("üîÑ –ó–∞–ø—É—Å–∫ –≤ polling —Ä–µ–∂–∏–º–µ")
            self.bot.polling(none_stop=True)

if __name__ == "__main__":
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    requirements = """
–î–ª—è —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å:
pip install telebot flask requests beautifulsoup4 cloudscraper
"""
    print(requirements)
    
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    try:
        bot = YaltaPodslushanoBot()
        bot.run()
    except KeyboardInterrupt:
        logger.info("üëã –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        logger.error(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        print("\n‚ùå –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:")
        print("1. –ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω TOKEN –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        print("2. –ü—Ä–æ–±–ª–µ–º—ã —Å —Å–µ—Ç—å—é –∏–ª–∏ –¥–æ—Å—Ç—É–ø–æ–º –∫ Telegram API")
        print("\nüîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å...")
        time.sleep(5)
